;30.5.97, 24.7.97
;23.9.97 - C128 version
;more in December '97
;17.05.98 - fixed driver swapper
;22.08.99 - changed dirhead position
;27.08.99 - internal ram version
;28.08.99 - single drive setup support
;20.07.00 - HDD (1ST VERSION)
;05.08.01 - HDD (2ND VERSION)
;06.08.01 - ACME port, REU installation ability, GEOS64/128 common
;08.08.01 - maximized bastard

!source "inc/const.inc"
!source "inc/jumptab.inc"
!source "inc/geossym.inc"
!source "inc/geosmac.acme.inc"
!source "inc/ide3.inc"

!cpu 6502

!set machine		= 128			; 64 for C64, 128 for C128
!set useCHS		= 0			; 0 - true, !=0 false

    !if (machine=64) {
	SWAPDRVBASE = $9eaa
	SETDEVBASE = $d6b0
	!to "inithdd.64"
    } else {
	SWAPDRVBASE = $9f57
	SETDEVBASE = $e5f5
	!to "inithdd.128"
    }

swapLength	= 12	; this includes the last page (e.g. 13->$9Dxx will be swapped too)

myDrvType	= $81				; disk type for my drive

		*= $1000+2
		
		JMP initAsk
;---------------------------------------
initDialog	!byte DEF_DB_POS | 1
		!byte DBTXTSTR, 10, 20
		!word initDText
		!byte DBGETSTRING, 10, 40, a0, 1
		!byte NULL

initDText	!byte BOLDON
		!text "Erase HDD (Y/N)?"
		!byte PLAINTEXT, 0

txtBuffer	!byte 0,0
initFeel	!byte 0
;---------------------------------------

initAsk		+LoadB txtBuffer, 0
		+LoadW r0, initDialog
		+LoadW a0, txtBuffer
		JSR DoDlgBox
		LDA txtBuffer
		AND #%00011111
		CMP #$19			;Y
		BEQ yesInit
		CMP #$0E			;N
		BEQ noInit
		BNE initAsk
yesInit		LDA #0				; YES
		!byte $2c
noInit		LDA #1				; NO
		STA initFeel

;---------------------------------------

		LDX #0
instLp		LDA driveType,x
		BMI REUInst_1
		INX
		CPX #4
		BNE instLp
		JMP NonREUInst
		
REUInst_1	INX
		CPX #4
		BEQ REUInstEnd
		LDA driveType,x
		BNE REUInst_1
		LDA #myDrvType
		STA driveType,x

;part below is extracted from GEOS Kernal
		LDA SetDevDrivesTabL,x
		STA SetDevTab + 2
		LDA SetDevDrivesTabH,x
		STA SetDevTab + 3
		LDX #6
REUInst_2	LDA SetDevTab,x
		STA r0,x
		DEX
		BPL REUInst_2
		JSR StashRAM
REUInstEnd	JMP finishInst

REUDskDrvSPC	=    $8300			; base for 4*DISK_DRV_LGH disk drivers

SetDevTab
		!word DSKDRV
		!word $0000
		!word DISK_DRV_LGH
		!byte $00

SetDevDrivesTabL
		!byte <REUDskDrvSPC+(0*DISK_DRV_LGH)
		!byte <REUDskDrvSPC+(1*DISK_DRV_LGH)
		!byte <REUDskDrvSPC+(2*DISK_DRV_LGH)
		!byte <REUDskDrvSPC+(3*DISK_DRV_LGH)
SetDevDrivesTabH
		!byte >REUDskDrvSPC+(0*DISK_DRV_LGH)
		!byte >REUDskDrvSPC+(1*DISK_DRV_LGH)
		!byte >REUDskDrvSPC+(2*DISK_DRV_LGH)
		!byte >REUDskDrvSPC+(3*DISK_DRV_LGH)

NonREUInst
    !if (machine=64) {
		LDX #1
NonREU_1	LDA driveType,x
		BEQ NonREU_2
		INX
		CPX #4
		BNE NonREU_1
		JMP finInstEnd
NonREU_2	LDA #myDrvType
		STA driveType,x
    } else {
		LDA driveType+1
		BEQ InternalInst
		CMP driveType
		BEQ InternalInst

		+LoadB driveType+2, myDrvType
    }
; two different drivers, third one goes through own swapper

		+LoadB ramExpSize, (128/64)
		+LoadB sysRAMFlg, %01000000

		JSR i_MoveData
		!word SETDEV			; SetDevice patch
		!word SETDEVBASE
		!word (DSKDRV-SETDEV)
		JSR i_MoveData
		!word SWAPDRV			; Swapper
		!word SWAPDRVBASE
		!word (SETDEV-SWAPDRV)

		JSR i_MoveData			; swapout driver
		!word DISK_BASE			; current to safe place
		!word $2000
		!word $0E00
		JSR i_MoveData			; driver->current
		!word DSKDRV
		!word DISK_BASE
		!word (swapLength*$0100)
		JSR Swapper			; swapout our driver
		JSR i_MoveData
		!word $2000
		!word DISK_BASE
		!word $0E00			; restore current

		JMP finishInst

;---------------------------------------
    !if (machine=128) {
InternalInst
		LDX #1				; insert in free driveType slot
		LDA driveType+1
		BEQ intInst_1
		INX
intInst_1	LDA #myDrvType
		STA driveType,X

		;+LoadW r0, DSKDRV
		LDA #>DSKDRV
		STA r0H
		LDA #<DSKDRV
		STA r0L
		LDA #0
		LDX #$D0			; bank0 swapped driver base
		STA r1L
		STX r1H
		STA r2L
		LDA #swapLength
		STA r2H
		LDX #1				; from bank1
		STX r3L
		DEX
		STX r3H				; to bank0
		JSR MoveBData
    }
finishInst      LDA initFeel			; initialize (format) device?
		BNE finInstEnd			; no

		+PushB curDevice		; set our device as current
		LDX #9
		LDA driveType+1
		BMI intInst_2
		INX
intInst_2	TXA
		JSR SetDevice

		LDX #0
intInst_3	LDA BAM,X
		STA curDirHead,X
		LDA #%11111111
		STA dir2Head,X
		STA dir3Head,X
		STA dir4Head,X
		STA dir5Head,X
		STA dir6Head,X
		STA dir7Head,X
		STA dir8Head,X
		LDA #0
		STA diskBlkBuf,X
		INX
		BNE intInst_3
		DEX
		STX diskBlkBuf+1

		+LoadB r6L, DIR_TRACK
		+LoadB r6H, 0
		JSR AllocateBlock
		+LoadB r6H, 1
		JSR AllocateBlock
		+LoadB r6H, 120
initAllocDir	JSR AllocateBlock
		INC r6H
		+CmpBI r6H, 128
		BNE initAllocDir

		JSR PutDirHead

		+LoadB r1L, DIR_TRACK
		+LoadB r1H, 1		; first directory sector
		JSR WriteBuff

		+LoadB r1L, DIR_TRACK
		+LoadB r1H, 127
		JSR WriteBuff		; border directory

		PLA
		JSR SetDevice		; restore device number

finInstEnd	JMP EnterDeskTop

;---------------------------------------

BAM		!binary "bin/bam.hdd",,2

SWAPDRV
		!pseudopc SWAPDRVBASE
	!if (machine=128) {
		!source "swapdrv128hdd.tas"
	} else {
		!source "swapdrv64hdd.tas"
	}
		!realpc

SETDEV
		!pseudopc SETDEVBASE
	!if (machine=64) {
		!source "setdevice64.tas"
	} else {
		!source "setdevice128.tas"
	}
		!realpc

DSKDRV
		!pseudopc DISK_BASE
		!source "drv/ide-hdd.tas"
		!realpc
